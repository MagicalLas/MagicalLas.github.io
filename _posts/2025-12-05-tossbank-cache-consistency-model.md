---
layout: post
title: "That's not strong consistency cache architecture"
slug: tossbank-strong-cache
category: essay
---

## urge to write this article

회사에서 이야기를 나누다가 어떤 아티클을 공유받았습니다. 토스뱅크에서 작성한 캐시에 대한 글이었고,
꽤나 어려워보이는 개념들을 이야기하면서 멋진 시스템 개선 방식을 소개하고있어서 즐겁게 읽었습니다. 
한편으로는 분산 시스템에서의 strong consistency를 적용하는 방식이 꽤나 특이하다는 느낌도 받았습니다. 
읽다보니 점점 엄밀한 잣대로 글을 읽게 되더군요. 제 안의 분산시스템 악마가 깨어나고 있었습니다.
이렇게 간단히 성능 저하 없이 문제글 잘 해결하는게 불가능하다는 생각이 들면서 몇가지 반례를 찾아내었습니다.
이미 저 글의 표현이 잘못되었다는건 확인했지만, 단순히 트집잡기에 불과하여 글을 약 반년간 방치했는데요.
이번에 저도 분산 시스템의 안정성을 검증해야하는 일이 생겨서 좋은 훈련으로 사용해보았습니다.

> 멋진 캐시 적용 아티클을 비난하고싶은 마음은 없습니다. 토스 뱅크의 기술력은 뛰어나다고 생각하며,
> 매우 거대한 시스템을 안정적으로 운영하는 몇 안되는 은행입니다. 저의 전세 대출도 여기서 받았습니다 ;>

## 아티클을 요약하자면

약관 데이터 서빙을 leader DB(아마 RDBMS겠죠?)에서만 수행하고 있었습니다. 이는 '강한 일관성;'이라고 하는 속성을 지키기 위함이라고 합니다.
요청이 점점 늘어나감에 따라서 단일 DB 인스턴스로는 성능 한계에 도달하게 됩니다.
따라서 빠르게 읽기를 할 수 있는 캐시 레이어를 도입합니다. 이때 redis를 캐시 저장소로 선택하고,
write시에 cache evict, read시에 cache를 채우는 방식으로 구현을 합니다.
일관성이 매우 중요하기 때문에 Kafka 이벤트 발행 순서도 조절하고, redis에 대하여 서킷도 달았습니다.

write시에 cache evict하는 타이밍은 db에 commit이 된 다음 application server에서 redis unlink를 수행하고, 성공적으로 redis unlink가 수행되면 API의 응답을 주게 됩니다.

## 일관성 모델

이렇게만 되면 실제로 강한 일관성이라고 하는 것을 보장하기 어려운데요, 캐시 레이어가 있다면 결국 불일치가 생기고 Total Order를 만들었을 때 일관성의 문제가 생깁니다.
그래서 개발자분은 일관성 모델을 조절하는데요, 저는 단 하나의 속성에 집중하려고합니다. Read Your Writes이죠.

이는 블로그의 주장보다 조금은 느슨한 속성입니다. 쓰기가 성공했다면, 그 다음 요청은 그 쓰기를 포함한 최신의 값을 반환해야합니다.
Monotonic Read(Flickering)과 같은 속성은 지금은 무시하도록합니다.

## TLA+ Spec으로 정의하기

저는 이번 검증에서 TLA+를 사용하겠습니다. 단순한 반례 몇가지를 찾는 것은 매우 쉽지만, 개개인의 상상력에 의존합니다.
게다가 개인의 상상력은 매우 빈곤합니다. 분산 시스템에서는 몇가지의 상호작용도 몇억가지의 시나리오로 만들어집니다. 
개발자 한명이 생각할 수 있는 시나리오는 고작해야 한번에 20가지가 전부이고, 수천만건이 있는 상황을 빠짐없이 시뮬레이션하는 것은 불가능하죠. 이는 컴퓨터가 잘 하는 것입니다. 
어떤 컴포넌트의 문제가 있다는 것을 잘 드러낼 수 있는 방법인 Formal Method를 사용하여 모델링을 시작해보겠습니다

유저는 한명이지만, 동시에 여러 요청을 보낼 수 있다고 가정하겠습니다.
App에서 요청을 보내는 경우 단 하나의 요청만 보내는 경우는 거의 없기도하고, 서버 안에서 요청이 퍼지면서 여러 요청으로 퍼지면서 비슷한 요청이 동시에 들어올 수도 있습니다.
강한 일관성이라면 이러한 문제에서 자유롭겠지요. 하지만 우리는 그정도로 원하지 않으니 단 하나의 속성만 체크하겠습니다. 
동일한 유저의 요청 스레드라면 자신이 write에 성공한 이후에 새로 시작하는 read에서는 write가 반영되어야한다는 것입니다.

아래와 같이 Read와 Write의 시퀀스가 만들어집니다. 모든 network은 지연이 있을 수 있지만, 단일 커넥션에 대하여 순서가 바뀌는 일은 없습니다. 또한 유실이 없고, 모든 요청은 실패하는 일이 없습니다. 실제로는 실패하는 경우도 있기에 더 상황이 복잡해집니다.

## 반례

이렇게 단순한 모델, 그리고 네트워크 지연만 있는 경우에도 문제는 발생합니다. 




## 서킷브레이커는 도움이 되지 않는다

## DB Transaction으로는 도움이 되지 않는다

## 대안 1 - lock

## 대안 2 - lamport timestamp

## 마무리