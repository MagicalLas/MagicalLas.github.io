---
layout: post
title: "Golang GC"
slug: golang-gc
category: mem
---

Golang은 GC(garbage collector)를 갖고있는 언어입니다. 이 글에서는 Golang의 GC를 자세하게 살펴보겠습니다.

---

Golang의 GC는 concurrent mark and sweep GC이며, 비세대화(non-generational) & 비압축(non-compacting) GC입니다. 하나하나 풀어나가보겠습니다.

## Traditional Mark and Sweep

concurrent mark and sweep은 mark and sweep을 concurrent하게 실행하는 GC 알고리즘입니다. mark and sweep은 매우 전통적인 GC 알고리즘인데, 우리는 일단 concurrent하지 않은 일반 버전의 mark and sweep을 먼저 알아보겠습니다.

mark and sweep은 mark와 sweep의 2가지 단계로 이루어져있습니다. 단순하게 말하자면 mark하고 sweep하죠. mark는 우리가 청소해야할 영역이 어디인지 확인하고 sweep은 실제로 청소합니다.

mark 과정을 먼저 살펴보겠습니다. mark는 사용되고 있는 메모리를 전부 mark(체크, 혹은 표시)합니다. 메모리(주로 힙)에 존재하는 객체들은 그래프 형식을 띄고 있습니다. 다음은 예시 golang 코드와 메모리 구조입니다.

![mem structure sample ](https://github.com/MagicalLas/MagicalLas.github.io/blob/master/_screenshots/golang-gc-01.png?raw=true)

보통 root라고 부르는 특정 위치로부터 접근가능한 자식 객체들을, 그리고 자식 객체에서 접근가능한 자식 객체들을 탐색하면서 mark하게 됩니다. 이 과정이 전부 끝나면 mark되지 않은 객체들은 root로부터 접근가능하지 않다고 할 수 있습니다. 따라서 mark되지 않은 모든 곳은 새로운 객체를 할당할 수 있는 공간입니다.

sweep은 모든 힙을 검사하면서 mark되어있지 않은 메모리들을 해제합니다. 이렇게 보면 간단하고 쉬운 알고리즘같습니다. 조금 더 디테일을 살펴보기 위하여 tri-color abstraction을 알아봅시다.

tri-color abstraction은 mark and sweep의 작업 상태를 추상화하는 방법입니다. tri-color라는 말처럼 3가지 색상으로 객체를 마크합니다

1. black
2. grey
3. white

**black**은 접근할 수 있는 객체를 의미하며 지워져서는 안됩니다. 간단하게 이미 mark가 끝난 객체라고 볼 수도 있습니다. **grey**는 black과 유사하지만 다른데, root로부터 접근은 가능하지만 아직 모든 자식 객체들이 mark되지 않아서 mark단계가 끝나지 않았음을 암시합니다. **white**는 mark되지 않은 객체를 의미합니다. sweep 단계에서 white객체들을 해제하게 됩니다.

최초의 모든 노드(객체)들은 white인 상태에서 시작합니다. marking단계에 접어들었을 때 mutator root를 시작으로 marking이 진행됩니다. 노드를 처음 만난다면 grey로 색칠하고, 그 노드의 자식을 모두 식별했다면 black으로 채색합니다.

이렇게 추상화했을 때, mark단계가 실행중이라면 black객체, grey 객체, white 객체가 각각 존재하게 됩니다. grey 객체가 있다는 것은 아직 grey객체의 자식중에 mark(grey or black)가 되지 않은 것이 존재함을 의미합니다. 따라서 sweep단계로 진입하기 전에는 grey객체가 없어야 안전하게 메모리 해제를 진행할 수 있습니다.

```
tri-color abstraction은 다음의 불변식(invariant)을 만족합니다

1. mark가 끝났으면 black객체로 부터 white객체들은 전부 접근이 불가능한 객체입니다.
2. mark가 끝났으면 grey객체가 없습니다.
```

tri-color abstraction과 관련해서 더 자세히 알고싶으신 분들은 다음 논문을 참고해주세요. [On-the-Fly Garbage Collection: An Exercise in Cooperation](https://lamport.azurewebsites.net/pubs/garbage.pdf)

---

## marking bitmap

특정 객체가 mark되었다는 정보를 저장하는 것은 중요하다 우리는 아래의 문서를 통하여 어떻게 mark하는지 살펴볼 수 있다


ref: https://go.googlesource.com/proposal/+/master/design/12800-sweep-free-alloc.md

---

## Concurrent Mark and Sweep

read barrier, write barrier

---


[src/runtime/mgc.go](https://github.com/golang/go/blob/master/src/runtime/mgc.go)를 살펴보면 Golang의 GC구현을 살펴볼 수 있습니다.

### 가비지 컬렉터에서 자주 쓰이는 primitive / 용어들

#### Heap

힙은 컴퓨터 메모리에서 프로그램이 필요에 따라 데이터를 저장하고 제거하는 영역입니다. 이 공간은 자유롭게 사용할 수 있으며, 여러분이 변수나 객체를 생성하면 그 정보는 힙에 저장됩니다. 힙에 저장된 데이터는 프로그램이 더 이상 사용하지 않을 때, 가비지 컬렉터에 의해 제거됩니다. Heap(힙)은 연속적인 메모리 워드의 배열, 연속적인 워드의 불연속적인 블록의 집합으로 이루어집니다.

#### 객체

객체는 메모리에서 프로그램이 사용하는 데이터의 집합을 나타냅니다. 객체는 특정 유형의 데이터를 나타내며, 이 데이터는 메모리의 연속된 영역, 즉 힙(heap)에 저장됩니다. 예를 들어, '학생'이라는 객체는 이름, 학번, 성적 등의 정보를 포함할 수 있습니다. 이 객체가 생성되면, 해당 정보는 힙 영역에 저장되며, 프로그램은 이 영역에 있는 데이터에 액세스하고 조작할 수 있습니다.

#### 뮤테이터

쉽게 말해 뮤테이터는 프로그램의 일부분으로, 객체를 생성하고 변경하고 삭제하는 역할을 합니다. 여러분이 코딩해서 만드는 대부분의 프로그램 코드는 뮤테이터로 볼 수 있습니다.

#### 뮤테이터 루트

뮤테이터 루트는 프로그램 코드(뮤테이터)가 현재 사용하고 있는, 즉 접근 가능한 모든 객체들의 '시작점'을 말합니다. 이는 변수나 함수 등에서 참조되는 모든 객체를 포함합니다. 가비지 컬렉터는 뮤테이터 루트를 통해 어떤 객체가 아직 필요하고 어떤 객체를 제거해도 되는지를 판단합니다.
