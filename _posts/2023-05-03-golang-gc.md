---
layout: post
title: "Golang GC"
slug: golang-gc
category: mem
---

Golang은 GC(garbage collector)를 갖고있는 언어입니다. 이 글에서는 Golang의 GC를 자세하게 살펴보겠습니다.

---

Golang의 GC는 concurrent mark and sweep GC이며, 비세대화(non-generational) & 비압축(non-compacting) GC입니다. 하나하나 풀어나가보겠습니다.

## Mark and Sweep

concurrent mark and sweep은 mark and sweep을 concurrent하게 실행하는 GC 알고리즘입니다. mark and sweep은 매우 전통적인 GC 알고리즘인데, 우리는 일단 concurrent하지 않은 일반 버전의 mark and sweep을 먼저 알아보겠습니다.

mark and sweep은 mark와 sweep의 2가지 단계로 이루어져있습니다. 단순하게 말하자면 mark하고 sweep하죠. mark는 우리가 청소해야할 영역이 어디인지 확인하고 sweep은 실제로 청소합니다.

mark 과정을 먼저 살펴보겠습니다. mark는 사용되고 있는 메모리를 전부 mark(체크, 혹은 표시)합니다. 메모리(주로 힙)에 존재하는 객체들은 그래프 형식을 띄고 있습니다. 다음은 예시 golang 코드와 메모리 구조입니다.

![mem structure sample ](https://github.com/MagicalLas/MagicalLas.github.io/blob/master/_screenshots/golang-gc-01.png?raw=true)

보통 root라고 부르는 특정 위치로부터 접근가능한 자식 객체들을, 그리고 자식 객체에서 접근가능한 자식 객체들을 탐색하면서 mark하게 됩니다. 이 과정이 전부 끝나면 mark되지 않은 객체들은 root로부터 접근가능하지 않다고 할 수 있습니다. 따라서 mark되지 않은 모든 곳은 새로운 객체를 할당할 수 있는 공간입니다.

sweep은 모든 힙을 검사하면서 mark되어있지 않은 메모리들을 해제합니다. 이렇게 보면 간단하고 쉬운 알고리즘같습니다. 조금 더 디테일을 살펴보기 위하여 tri-color abstraction을 알아봅시다.

tri-color abstraction은 mark and sweep의 작업 상태를 추상화하는 방법입니다. tri-color라는 말처럼 3가지 색상으로 객체를 마크합니다

1. black
2. grey
3. white

**black**은 접근할 수 있는 객체를 의미하며 지워져서는 안됩니다. 간단하게 이미 mark가 끝난 객체라고 볼 수도 있습니다. **grey**는 black과 유사하지만 다른데, root로부터 접근은 가능하지만 아직 모든 자식 객체들이 mark되지 않아서 mark단계가 끝나지 않았음을 암시합니다. **white**는 mark되지 않은 객체를 의미합니다. sweep 단계에서 white객체들을 해제하게 됩니다.

최초의 모든 노드(객체)들은 white인 상태에서 시작합니다. marking단계에 접어들었을 때 mutator root를 시작으로 marking이 진행됩니다. 노드를 처음 만난다면 grey로 색칠하고, 그 노드의 자식을 모두 식별했다면 black으로 채색합니다.

이렇게 추상화했을 때, mark단계가 실행중이라면 black객체, grey 객체, white 객체가 각각 존재하게 됩니다. grey 객체가 있다는 것은 아직 grey객체의 자식중에 mark(grey or black)가 되지 않은 것이 존재함을 의미합니다. 따라서 sweep단계로 진입하기 전에는 grey객체가 없어야 안전하게 메모리 해제를 진행할 수 있습니다.

```
tri-color abstraction은 다음의 불변식(invariant)을 만족합니다

1. mark가 끝났으면 black객체로 부터 white객체들은 전부 접근이 불가능한 객체입니다.
2. mark가 끝났으면 grey객체가 없습니다.
```

tri-color abstraction과 관련해서 더 자세히 알고싶으신 분들은 다음 논문을 참고해주세요. [On-the-Fly Garbage Collection: An Exercise in Cooperation](https://lamport.azurewebsites.net/pubs/garbage.pdf)

---

### Golang's Implementation

Golang의 GC 구현을 살펴보는 것으로 가장 좋은 시작지점은 src/runtime/mgc.go입니다. 이 코드를 읽어내려가다보면 'gcStart(trigger gcTrigger)'를 확인할 수 있습니다. 이 부분이 GC를 시작하는 부분이며, 내부 구현을 좀 더 자세히 살펴볼 수 있습니다.

함수의 대략적인 구현(동작)은 다음과 같습니다.

1. 가비지 컬렉션 시작 조건 확인

이 단계는 함수 시작 부분에서 acquirem() 함수를 호출한 후에 발생합니다.

2. 가비지 컬렉션 모드 설정

이 단계는 debug.gcstoptheworld 값을 확인하여 가비지 컬렉션의 모드를 결정합니다. Go의 GC는 기본적으로 gcBackgroundMode로 background에서 실행되지만, debug.gcstoptheworld 값에 따라서 STW로도 실행이 가능합니다.

3. 세계를 정지시키고 스윕 단계 종료

"세계를 정지시키는" 작업은 semacquire(&gcsema)와 semacquire(&worldsema)에서 이루어집니다. semapore를 얻은 다음 stopTheWorldWithSema(reason stwReason)을 실행하여 실제로 stop the world를 실행합니다.

STW상태에서 finishsweep_m 함수를 호출하여 sweep 단계를 종료합니다.

4. 가비지 컬렉션 모드에 따라서 스케줄러 조정

뒤에 나올 mark단계는 background에서 동시에 실행될 수 있습니다. 2단계에서 설정한 가비지 컬렉션 모드에 따라서 만약 background mode가 아니라면 유저의 고루틴들이 스케줄링 되는 것을 막습니다.

5. 마킹 단계 시작

마킹 단계는 GC의 phase를 _GCmark로 설정하는 것으로 시작합니다. 몇몇 mark단계 실행을 위한 준비들을 진행합니다.

뒤에서 소개하겠지만, 이 단계 이후부터 생성되는 객체들은 모두 black으로 칠해집니다.

6. STW를 해제하고, mark를 진행합니다.

background worker들이 mutator root로부터 시작하여 greyobject들을 처리하기 시작합니다.

7. 가비지 컬렉션 시작의 완료 후 정리

가비지 컬렉션의 시작 완료와 이후 정리 작업이 이루어집니다. 여기서 유저의 고루틴이 다시 시작되고 필요한 세마포어(semaphore)가 해제됩니다.

이 시점에도 background worker들은 marking을 진행하고 있습니다.

8. worker들이 전부 mark를 실행했고, mark단계를 끝낸다

marking을 진행할 것이 남았다면 다시 check하고 marking을 진행합니다.

전부 marking이 진행되었다면 stopTheWorldWithSema(stwGCMarkTerm)를 통하여 STW를 실행하고, GC의 phase를 _GCmarktermination로 설정합니다. mark가 전부 되었는지 확인하고나서 GC phase를 _GCoff로 변경합니다.

9. Sweep을 진행한다



---

### Marking Mechanism

특정 객체가 mark되었다는 정보를 저장하는 것은 중요합니다. 우리는 아래의 문서를 통하여 어떻게 mark하는지 살펴볼 수 있다

ref: https://go.googlesource.com/proposal/+/master/design/12800-sweep-free-alloc.md

---

### Concurrently Running Mark and Sweep

read barrier, write barrier

---


[src/runtime/mgc.go](https://github.com/golang/go/blob/master/src/runtime/mgc.go)를 살펴보면 Golang의 GC구현을 살펴볼 수 있습니다.

### 가비지 컬렉터에서 자주 쓰이는 primitive / 용어들

#### Heap

힙은 컴퓨터 메모리에서 프로그램이 필요에 따라 데이터를 저장하고 제거하는 영역입니다. 이 공간은 자유롭게 사용할 수 있으며, 여러분이 변수나 객체를 생성하면 그 정보는 힙에 저장됩니다. 힙에 저장된 데이터는 프로그램이 더 이상 사용하지 않을 때, 가비지 컬렉터에 의해 제거됩니다. Heap(힙)은 연속적인 메모리 워드의 배열, 연속적인 워드의 불연속적인 블록의 집합으로 이루어집니다.

#### 객체

객체는 메모리에서 프로그램이 사용하는 데이터의 집합을 나타냅니다. 객체는 특정 유형의 데이터를 나타내며, 이 데이터는 메모리의 연속된 영역, 즉 힙(heap)에 저장됩니다. 예를 들어, '학생'이라는 객체는 이름, 학번, 성적 등의 정보를 포함할 수 있습니다. 이 객체가 생성되면, 해당 정보는 힙 영역에 저장되며, 프로그램은 이 영역에 있는 데이터에 액세스하고 조작할 수 있습니다.

#### 뮤테이터

쉽게 말해 뮤테이터는 프로그램의 일부분으로, 객체를 생성하고 변경하고 삭제하는 역할을 합니다. 여러분이 코딩해서 만드는 대부분의 프로그램 코드는 뮤테이터로 볼 수 있습니다.

#### 뮤테이터 루트

뮤테이터 루트는 프로그램 코드(뮤테이터)가 현재 사용하고 있는, 즉 접근 가능한 모든 객체들의 '시작점'을 말합니다. 이는 변수나 함수 등에서 참조되는 모든 객체를 포함합니다. 가비지 컬렉터는 뮤테이터 루트를 통해 어떤 객체가 아직 필요하고 어떤 객체를 제거해도 되는지를 판단합니다.
