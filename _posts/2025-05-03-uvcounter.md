---
layout: post
title: "single-millis-counter"
slug: uvcounter
category: essay
---

## Golang low latency application

### Latency & Throughput Optimization

다른 제품의 기반이 되는 플랫폼은 편하게 부담없이 사용하는게 매우 중요하다. 우리가 사용하는 제품도 동일하다. 텍스트 에디터에서 100ms의 지연이 1분마다 발생한다면 어떨까? 웹 페이지를 이동할 때 어떤 페이지는 첫 화면이 1초가 넘게 걸린다면 어떨까? 사용하는데 전혀 문제는 없지만 기분이 매우 안좋아진다. 이렇듯 latency는 사용성에 매우 중요한 요소이다.

tail latency는 전체 요청 중 상위 0.01%에 해당하는 지연 시간(p99.99)과 같이 드물게 발생하지만, 사용자 경험에 큰 영향을 줄 수 있다.

### h2load test

성능 테스트를 할 때 tail latency는 다양한 원인으로 늘어날 수 있다.

흔히 하는 실수는 성능 테스트를 하는 노드가 분리되어있지 않은 경우이다. 머신 한대를 받아서 성능 테스트를 해본다고 하자. go process가 http 서버 형태로 떠있고, 같은 노드에서 h2load를 사용해서 localhost로 요청을 보내는 경우 정확한 측정이 가능할까??

당연히 아니다. latency는 대부분의 경우 queue에서 대기하는 경우에 발생한다. 우리는 이 테스트에서 cpu 자원을 공유하고 있고, 같은 cpu core를 공유하기에 경쟁이 생길 수 있다. run queue에 여러 프로세스가 대기하고 있다면 다른 process는 cpu 자원을 할당받지 못한 시간동안 지연이 발생한다.

이러한 지연은 profiling으로는 빠르게 찾기 어려울 수 있는데, 어떠한 syscall, 혹은 함수에서 느려지는 것을 발견하면 이게 단순히 지연인 것인지 자원 경합인 것인지 process레벨에서는 확인하지 못하기 때문이다.

나는 간단하게 run queue를 모니터링해보는 것을 추천하는데, 내가 사랑하는 sysstat도구중 하나인 sar를 사용하는 방법이다. `sar -q 1`를 실행하면 cpu의 queue를 1초마다 출력해준다. 만약 노드의 cpu가 모든 코어에서 100%를 사용하는 현상을 발견했다면 이러한 도구를 사용해보자. (모든 core가 일하고 있는 것은 `mpstat 1 -P ALL`으로 확인할 수 있다.)

run queue는 다른 방식으로도 모니터링할 수 있는데, 매우 강력한 eBPF를 사용하면 좋다. runqlat와 같은 도구는 run queue자체보다는 작업이 얼마나 대기하고 실행되는지에 대한 메트릭을 볼 수 있다. queue에 차는 것 보다 이 방법이 더 정확하지만, 사용하는 것에 제약이 있다는 것이 단점이다.
